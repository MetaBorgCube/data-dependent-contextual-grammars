/**
 *
 * Extracted from the OCaml reference manual 4.00 by Ali Afroozeh
 *
 * Converted to Iggy Reference format by Michael J.Steindorfer
 *
 */

// Top-level

start
  ::= TopLevel

TopLevel
  ::= TopLevelPhrase*

TopLevelPhrase
  ::= Definition
    | Expr

CompilationUnit
  ::= ModuleItems?

// Names

ValuePath
  ::= (ModulePath ".")? ValueName      <valuePath>

ValueName
  ::= LowercaseIdentifier
    | "(" OperatorName ")"

OperatorName
  ::= PrefixSymbol
    | InfixSymbol

TagName
  ::= Ident

TypeconstrName
  ::= LowercaseIdentifier

TypeConstr
  ::= (ExtendedModulePath ".")? TypeconstrName

ConstrName
  ::= CapitalizedIdentifier

LabelName
  ::= LowercaseIdentifier

ModuleName
  ::= CapitalizedIdentifier

FieldName
  ::= LowercaseIdentifier

ClassName
  ::= LowercaseIdentifier

InstVarName
  ::= LowercaseIdentifier

MethodName
  ::= LowercaseIdentifier

ModTypeName
  ::= Ident

ModulePath
  ::= (ModuleName ".")* ModuleName

Constr
  ::= (ModulePath ".")? ConstrName

Field
  ::= (ModulePath ".")? FieldName

ClassPath
  ::= (ExtendedModulePath "." )? ClassName

ModTypePath
  ::= (ExtendedModulePath "." )? ModTypName

ModTypName
  ::= Ident

ExtendedModulePath
  ::= ExtendedModuleName ( "." ExtendedModuleName )*

ExtendedModuleName
  ::= ModuleName ("(" ExtendedModulePath ")")*


// Type expressions

Typexpr
  ::= "?"? LabelName ":" Typexpr
    > Typexpr TypeConstr
    > Typexpr "*" Typexpr_ ("*" Typexpr_)*                                              <star>              non-assoc           /* label "star"  */
    > Typexpr "->" Typexpr                                                              <arrow>             right               /* label "arrow" */
    > Typexpr "as" "\'" Ident
    > "private" Typexpr
    | "\'" Ident
    | "_" !>> [a-zA-Z0-9]
    | "(" Typexpr ")"
    | TypeConstr
    | "(" Typexpr ("," Typexpr)+ ")" TypeConstr
    | PolymorphicVariantType
    | "<" ".."? ">"
    | "<" MethodType (";" MethodType)* (";" "..")? ">"
    | "#" ClassPath
    | Typexpr "#" ClassPath
    | "(" Typexpr ("," Typexpr)* ")" "#" ClassPath
    | "(" "module" PackageType ")"

Typexpr_
  ::= Typexpr /*!star*/ /*!arrow*/

PolymorphicVariantType
  ::= "[" "|"? (TagSpec ("|" TagSpec)*)? "]"
    | "[>" (TagSpec ("|" TagSpec)*)? "]"
    | "[<" "|"? TagSpecFull ("|" TagSpecFull)* (">" ("`" TagName)+ )? "]"

PolyTypExpr
  ::= Typexpr
    | ("\'" Ident)+ "." Typexpr

MethodType
  ::= MethodName ":" PolyTypExpr

TagSpec
  ::= "`" TagName ("of" Typexpr)?
    | Typexpr

TagSpecFull
  ::= "`" TagName ("of" Typexpr)? ("&" Typexpr)*
    | Typexpr


// Expressions

Expr
  ::= PrefixSymbol Expr                <prefix>
    > Expr "." Ident                   <field>
    | Expr ".(" Expr ")"               <dotBracket1>
    | Expr ".[" Expr "]"               <dotBracket2>
    | Expr ".{" Expr "}"               <dotBracket3>
    | Expr "#" MethodName              <hash>
    > Expr /*!comma*/ Arg+             <functionApplication>         non-assoc
    //| constrExp:                Constr Expr                        non-assoc           /* To avoid ambiguities with Expr Arg+ as Expr can derive Constr */
    //| polyVariant:              "`" TagName Expr                   non-assoc           /* To Avoid ambiguities with Constant("`" TagName) Arg(Expr) */
    | lazy" Expr                       <lazy>                        non-assoc
    | assert" Expr                     <assertExpr>                  non-assoc
    > "-"  Exp                         <unaryMinus>
    | "-." Exp                         <floatUnaryMinus>
    > Expr InfixSymbol1 Expr           <infix1>                      right
    > Expr InfixSymbol2 Expr           <infix2>                      left
    > Expr InfixSymbol3 Expr           <infix3>                      left                /* to disambiguate [|   5.2026032092;     19132e-10;  -39e-10 |]; */
    > Expr "::" Expr                   <coloncolon>                  right
    > Expr InfixSymbol4 Expr           <infix4>                      right
    > Expr InfixSymbol5 Expr           <infix5>                      left
    > Expr InfixSymbol6 Expr           <infix6>                      right
    > Expr InfixSymbol7 Expr           <infix7>                      right
    > Expr ("," Expr_2)+               <comma>                       non-assoc
    > Expr "<-" Expr                   <assign>                      right
    > Expr InfixSymbol8 Expr           <infix8>                      right
    > "if" Expr "then" Expr_1 "else" Expr             <ifThenElse>
    | "if" Expr "then" Expr !>> "else"                <ifThen>                           /* was !>>> (follow restriction on productions???) */
    //> Expr ";" !>>  ";"  <semicolon>
    > Expr ";" Expr                                   <sep>          right
    > "match" Expr "with" PatternMatching !>> "|"     <match>                            /* was !>>> (follow restriction on productions???) */
    | "function" PatternMatching !>> "|"              <function>                         /* was !>>> (follow restriction on productions???) */
    | "fun" MultipleMatching                          <fun>
    | "try" Expr ";"? "with" PatternMatching !>> "|"  <tryBlock>                         /* was !>>> (follow restriction on productions???) */
    | "let" "rec"? LetBinding ";"? ("and" LetBinding ";"?)* "in" Expr          <letbinding>
    | "let" "module" ModuleExpr "="  ModuleExpr "in"  Expr                     <letModule>
    | "let" "open" ModulePath "in" Expr               <letOpen>
    | "(" Expr ";"? ")"                               <brackets>
    | "begin" Expr ";"? "end"                         <beginEnd>
    | "(" Expr ":" Typexpr ")"                        <brackets1>
    | "(" Expr ":>"  Typexpr ")"                      <brackets2>
    | "(" Expr ":"  Typexpr ":>"  Typexpr ")"         <brackets3>
    | "{<" InstVarName "=" Expr_1 (";" InstVarName "="  Expr)*  ";"? ">}"      <brackets4>
    | "["  Expr_1 (";" Expr_1)* ";"? "]"                                       <tupl>
    | "[|" Expr_1 (";" Expr_1)* ";"? "|]"                                      <array>
    | "{" Field ("=" Expr_1)? (";" Field ("=" Expr_1)?)* ";"? "}"              <record1>
    | "{" Expr "with" Field ("=" Expr_1 )? (";" Field ("=" Expr_1)?)* ";"? "}" <record2>
    | "while" Expr "do" Expr ";"? "done"                                       <whileloop>
    | "for" ValueName "=" Expr ("to" | "downto") Expr "do" Expr ";"? "done"    <forloop>
    | "new" ClassPath                                                          <new>
    | "object" ClassBody "end"                                                 <object>
    | "(" "module" ModuleExpr  (":" PackageType)? ")"                          <moduleExpr>
    //| ValuePath  <valuePath>
    | ValueName
    | Constant /*!constr*/ <constant>                                                    /* To avoid ambiguities with Expr "." Field. */
    | ConstrName
    //| InstVarName

Expr_1
  ::= Expr /*!sep*/

Expr_2
  ::= Expr /*!sep*/ /*!comma*/

Arg
  ::= Expr /*!functionApplication*/ /*!lazy*/ /*!assertExpr*/ /*!unaryMinus*/ /*!floatUnaryMinus*/ /*!infix1*/ /*!infix2*/ /*!infix3*/
           /*!coloncolon*/ /*!infix4*/ /*!infix5*/ /*!infix6*/ /*!infix7*/ /*!comma*/
           /*!infix8*/ /*!ifThenElse*/ /*!ifThen*/ /*!sep*/ /*!match*/ /*!function*/ /*!fun*/ /*!tryBlock*/ /*!letbinding*/ /*!letModule*/
    | Label                            <label>
    | LabelColon Expr /*!functionApplication*/ /*!lazy*/ /*!assertExpr*/ /*!unaryMinus*/ /*!floatUnaryMinus*/ /*!infix1*/ /*!infix2*/ /*!infix3*/
                      /*!coloncolon*/ /*!infix4*/ /*!infix5*/ /*!infix6*/ /*!infix7*/ /*!comma*/
                      /*!infix8*/ /*!ifThenElse*/ /*!ifThen*/ /*!sep*/ /*!match*/ /*!function*/ /*!fun*/ /*!tryBlock*/ /*!letbinding*/ /*!letModule*/
                                       <labelColon>
    | OptLabel                         <optlabel>
    | OptLabelColon Expr /*!functionApplication*/ /*!lazy*/ /*!assertExpr*/ /*!unaryMinus*/ /*!floatUnaryMinus*/ /*!infix1*/ /*!infix2*/ /*!infix3*/
                         /*!coloncolon*/ /*!infix4*/ /*!infix5*/ /*!infix6*/ /*!infix7*/ /*!comma*/
                         /*!infix8*/ /*!ifThenElse*/ /*!ifThen*/ /*!sep*/ /*!match*/ /*!function*/ /*!fun*/ /*!tryBlock*/ /*!letbinding*/ /*!letModule*/
                                       <optlabelColon>

PatternMatching
  ::= "|"? Pattern ("when" Expr)? "->" Expr InnerPatternMatching*

InnerPatternMatching
  ::= ";"? "|" Pattern ("when" Expr)? "->" Expr

LetBinding
  ::= Pattern /*!patternValueName*/ "=" Expr
    | ValueName Parameter* (":" PolyTypExpr)? (":>" Typexpr)? "=" Expr         <letBinding>
    | ValueName ":" "type" TypeConstr* "." Typexpr "=" Expr                    <bindingNew>

MultipleMatching
  ::= Parameter+ ("when" Expr)? "->" Expr                                      <multipleMatching>

Parameter
  ::= Pattern /*!constrPattern*/                                               <patternParam>      /* Paramter always comes in lists and can match another pattern */
    | Label                                                                    <param1>
    | "~" "(" LabelName (":" Typexpr)? ")"                                     <param2>
    | LabelColon Pattern                                                       <param3>
    | OptLabel                                                                 <param4>
    | "?" "(" LabelName (":" Typexpr)? ("=" Expr)? ")"                         <param5>
    | OptLabelColon Pattern                                                    <param6>
    | OptLabelColon "(" Pattern ":" Typexpr "=" Expr ")"                       <param7>
    | "(" "type" TypeconstrName ")"                                            <typeParam>

// Patterns

Pattern
  ::= "lazy" Pattern                                                           <lazyPattern>
    > Constr Pattern                                                           <constrPattern>
    > "`" TagName Pattern                                                      <tagNamePattern>
    > Pattern "::" Pattern                                                     <listCons>          right
    > Pattern "," Pattern_ ("," Pattern_)*                                     <patterns>          non-assoc
    > Pattern "|" Pattern                                                      <patternBar>        left
    > Pattern "as" ValueName                                                   <patternAs>
    | ValueName                                                                <patternValueName>
    | "_" !>> [a-zA-Z0-9]                                                      <anyPattern>        /* To enforce longest match with identifiers */
    | Constant                                                                 <patternConstant>
    | CharLiteral ".." CharLiteral                                             <patternRange>      /* Extensions */
    | "(" Pattern ")"                                                          <patternBrackets>
    | "(" Pattern ":" Typexpr ")"                                              <patternTypxprBrackets>
    | "#" TypeconstrName                                                       <patternHash>
    | "{" Field ("=" Pattern)? (";" Field ("=" Pattern)?)* (";" "_")? ";"? "}" <patternRec>
    | "["  Pattern (";" Pattern)* ";"? "]"                                     <patternTuple>
    | "[|" Pattern (";" Pattern)* ";"? "|]"                                    <patternArray>
    | "(" "module" ModuleName  (":" PackageType)? ")"                          <patternPackage>

Pattern_
  ::= Pattern /*!patterns*/ /*!patternBar*/ /*!patternAs*/

Constant
  ::= [\-] !<< IntegerLiteral !>> [0-9_A-Fa-f.eElLn]       <posInt>
    | [\-] !<< FloatLiteral !>> [0-9_.eE\-]                <floatLiteral>
    | CharLiteral                                          <charLiteral>
    | StringLiteral1                                       <stringLiteral>
    | Constr                                               <constr>
    | "false"                                              <falseConstant>
    | "true"                                               <trueConstant>
    | "(" ")"                                              <emptyParenthesis>
    | "[" "]"                                              <emptyBrackets>
    | "[|" "|]"                                            <emptyArray>
    | "{<" ">}"                                            <emptyCurly>
    | "`" TagName
    | [\-] !<< Int32Literal                                <int32>
    | [\-] !<< Int64Literal                                <int64>
    | [\-] !<< NativeIntLiteral                            <nativeInt>
    | "begin" "end"                                                                                /* An alias for "(" ")" */

// ModuleExpressions

Definition
  ::= "let" "rec"? LetBinding (";"? "and" LetBinding)*
    | "val" ValueName ":" Typexpr
    | "external" ValueName ":" Typexpr "=" ExternalDeclaration
    | TypeDefinition
    | ExceptionDefinition
    | ClassDefinition
    | ClassSpecification
    | ClassTypeDefinition
    | "module" ModuleName ( "(" ModuleName ":" ModuleType ")" )* ( ":" ModuleType )? "=" ModuleExpr
    | "module" ModuleName ("(" ModuleName ":" ModuleType ")")* ":" ModuleType
    | "module" "type" ModTypeName "=" ModuleType
    | "module" "type" ModTypeName
    | "module" "rec" ModuleName ":"  ModuleType "="  ModuleExpr  ("and" ModuleName ":"  ModuleType "="  ModuleExpr)*
    | "module" "rec" ModuleName ":"  ModuleType  ("and" ModuleName ":"  ModuleType)*
    | "open" ModulePath
    | "include" ModuleExpr /*!modulePath*/
    | "include" ModuleType

ModuleExpr
  ::= ModulePath                                                               <modulePath>
    | "struct" ";;"? ModuleItems? "end"
    | "functor" "(" ModuleName ":" ModuleType ")" "->" ModuleExpr
    | "functor" "(" ")" "->" ModuleExpr
    | ModuleExpr "(" ModuleExpr? ")"
    | ModuleExpr "(" ModuleExpr ":" ModuleType ")"
    | "(" ModuleExpr ")"
    | "(" ModuleExpr ":" ModuleType ")"
    | "(" "val" Expr (":" PackageType)? ")"

ModuleItems
  ::= ";;"? ( (Definition ";"?) | (Expr ";"?)) ((";;"? Definition ";"?) | (";;" Expr ";"?))* ";;"?

// ModuleTypes

ModuleType
  ::= ModTypePath                                                              <modTypePath>
    | "sig" ( Definition ";;"? )* "end"                                        <sig>
    | "module" "type" "of" ModuleExpr                                          <modTypeOf>
    | ModuleType "with" ModConstraint ("and" ModConstraint)*                   <modTypeWith>
    | ModuleType /*!modTypeWith*/ "(" ModuleType ")"                           <bracketModType2>
    > "functor" "(" ModuleName ":" ModuleType ")" "->" ModuleType              <functor>
    | "(" ModuleType ")"                                                       <bracketModType1>


ModConstraint
  ::= "type" TypeParams? TypeConstr "=" Typexpr
    | "type" TypeParameters? TypeConstr ":=" TypeParameters? TypeConstr
    | "module" ModulePath "=" ExtendedModulePath
    | "module" ModuleName ":=" ExtendedModulePath


// Type And Exceptions

TypeDefinition
  ::= "type" TypeDef ("and" TypeDef)*

TypeDef
  ::= TypeParams? TypeconstrName TypeInformation

TypeInformation
  ::= TypeEquation? TypeRepresentation? TypeConstraint*

TypeEquation
  ::= "=" Typexpr

TypeRepresentation
  ::= "=" "private"? "|"? ConstrDecl ("|" ConstrDecl)*
    | "=" "private"? "{" FieldDecl (";" FieldDecl)* ";"? "}"
    | "=" "[" (ConstrDecl ("|" ConstrDecl)*)? "]"                                                  /* Revised syntax */

TypeParams
  ::= TypeParam
    | "(" TypeParam ("," TypeParam)* ")"

TypeParam
  ::= Variance? "#"? "\'" Ident
    | Variance? "_" !>> [a-zA-Z0-9]

Variance
  ::= "+"
    | "-"

ConstrDecl
  ::= (ConstrName | ("(" ")")) ("of" Typexpr_ ("*" Typexpr_)*)?
    | ConstrName ":" Typexpr_ ("*" Typexpr_)* ("->"  Typexpr)?

FieldDecl
  ::= "mutable"? FieldName ":" PolyTypExpr

TypeConstraint
  ::= "constraint" "\'" Ident "=" Typexpr

ExceptionDefinition
  ::= "exception" ConstrName ("of" Typexpr_ ("*" Typexpr_ )* )?
    | "exception" ConstrName "=" Constr

// Classes

ClassType
  ::= ( Typexpr_ "->")* ClassBodyType

ClassBodyType
  ::= "object" ("(" Typexpr ")")? ClassFieldSpec* "end"
    | ("[" Typexpr ("," Typexpr)* "]")? ClassPath

ClassFieldSpec
  ::= "inherit" ClassType
    | "val" "mutable"? "virtual"? InstVarName ":" PolyTypExpr
    | "val" "virtual" "mutable" InstVarName ":" PolyTypExpr
    | "method" "private"? "virtual"? MethodName ":" PolyTypExpr
    | "method" "virtual" "private" MethodName ":" PolyTypExpr
    | "constraint" Typexpr "=" Typexpr

ClassExpr
  ::= ClassPath
    | "[" Typexpr ("," Typexpr)* "]" ClassPath                                 <classExprBrackets1>
    | "(" ClassExpr ")"                                                        <classExprBrackets2>
    | "(" ClassExpr ":" ClassType ")"                                          <classExprBrackets3>
    | ClassExpr /*!classArgs*/ Arg+                                            <classArgs>
    | "fun" Parameter+ "->" ClassExpr                                          <classFun>
    | "let" "rec"? LetBinding ("and" LetBinding)* "in" ClassExpr               <letClass>
    | "object" ClassBody "end"                                                 <object>

ClassField
  ::= ("inherit" | "inherit!") ClassExpr ("as" ValueName)?
    | ("val"|"val!") "mutable"? InstVarName (":" Typexpr)? "=" Expr
    | "val" "mutable"? "virtual" InstVarName ":" Typexpr
    | "val" "virtual" "mutable" InstVarName ":" Typexpr
    | ("method" | "method!") "private"? MethodName Parameter* (":" PolyTypExpr)? "=" Expr
    | "method" "private"? "virtual" MethodName ":" PolyTypExpr
    | "method" "virtual" "private"  MethodName ":" PolyTypExpr
    | "constraint" Typexpr "=" Typexpr
    | "initializer" Expr
    | ("method"|"method!") "private"? MethodName ":" "type" TypeconstrName+ "." Typexpr "=" Expr   /* Extensions ยง7.13 */

ClassDefinition
  ::= "class" ClassBinding ("and" ClassBinding)*

ClassBody
  ::= ("(" Pattern (":" Typexpr)? ")")? (ClassField ";"?)*

ClassBinding
  ::= "virtual"? ("[" TypeParameters "]")? ClassName Parameter* (":" ClassType)? "=" ClassExpr

TypeParameters
  ::= "\'" Ident ("," "\'" Ident)*

ClassSpecification
  ::= "class" ClassSpec ("and" ClassSpec)*

ClassSpec
  ::= "virtual"? ("[" TypeParameters "]")? ClassName ":" ClassType

ClassTypeDefinition
  ::= "class" "type" ClasstypeDef ("and" ClasstypeDef)*

ClasstypeDef
  ::= "virtual"? ("[" TypeParameters "]")? ClassName "=" ClassBodyType

ExternalDeclaration
  ::= StringLiteral1+


// Extensions

PackageType
  ::= ModTypePath
    | ModTypePath "with" PackageConstraint  ("and" PackageConstraint)*

PackageConstraint
  ::= "type" TypeConstr "=" Typexpr


// Lexical

regex /* was "lexical" */ {
Ident
  ::= LowercaseIdentifier
    | CapitalizedIdentifier
}

// underscore is considered a lower case identifier
@NoLayout /* was "lexical" */
LowercaseIdentifier
  ::= [a-zA-Z_0-9] !<< LowercaseIdentifierChars \ Keywords

regex /* was "token" */ {
LowercaseIdentifierChars
  ::= [a-z_][A-Za-z0-9_']*
}

@NoLayout /* was "lexical" */
CapitalizedIdentifier
  ::= [a-zA-Z_0-9] !<< CapitalizedIdentifierChars \ Keywords

regex /* was "token" */ {
CapitalizedIdentifierChars
  ::= [A-Z][A-Za-z0-9_']*
}

regex /* was "token" */ {
Int32Literal
  ::= [\-]? SpecialInt [l]
}

regex /* was "token" */ {
Int64Literal
  ::= [\-]? SpecialInt [L]
}

regex /* was "token" */ {
NativeIntLiteral
  ::= [\-]? SpecialInt [n]
}

regex /* was "token" */ {
SpecialInt
  ::= [0-9] [0-9_]*
    | ("0x"| "0X") [0-9A-Fa-f][0-9A-Fa-f_]*
    | ("0o"| "0O") [0-7] [0-7_]*
    | ("0b"| "0B") [0-1] [0-1_]*
}

regex /* was "token" */ {
IntegerLiteral
  ::= [\-]? [0-9] [0-9_]*
    | [\-]? ("0x"| "0X") [0-9A-Fa-f][0-9A-Fa-f_]*
    | [\-]? ("0o"| "0O") [0-7] [0-7_]*
    | [\-]? ("0b"| "0B") [0-1] [0-1_]*
}

regex /* was "token" */ {
FloatLiteral
  ::= [\-]? [0-9] [0-9_]* [eE] [+\-]? [0-9] [0-9_]*              // only with e
    | [\-]? [0-9] [0-9_]* [.] [0-9_]*                            // only with .
    | [\-]? [0-9] [0-9_]* [.] [0-9_]* [eE] [+\-]? [0-9] [0-9_]*  // with both . and e
}

regex /* was "token" */ {
CharLiteral
  ::= ['] (RegularChar | EscapeSequence) [']
}

regex /* was "token" */ {
EscapeSequence
  ::= ([\\] [\\ " ' n t b r])
    | ([\\] [0-9][0-9][0-9])
    | ([\\][x] [0-9A-Fa-f][0-9A-Fa-f])
}

regex /* was "token" */ {
StringLiteral1
  ::= ["] StringCharacter* ["]
}

regex /* was "token" */ {
StringCharacter
  ::= RegularCharStr
    | EscapeSequence
    | [\\][\n]
    | [\\][\ ]
}

regex /* was "token" */ {
RegularChar
  ::= [^ ' \\]
}

regex /* was "token" */ {
RegularCharStr
  ::= [^ " \\]
}

regex /* was "token" */ {
OperatorChar
  ::= [! $ % & * + \- . / : < = > ? @ ^ | ~]
}

// TODO PrefixSymbol /* was "lexical" */
//   ::= ([!] OperatorChar*) \ "!="
//      | [? ~] OperatorChar+

@NoLayout /* was "lexical" */
Label
  ::= "~" LowercaseIdentifier !>> ":"

regex /* was "lexical" */ {
LabelColon
  ::= "~" LowercaseIdentifier ":"
}

@NoLayout /* was "lexical" */
OptLabel
  ::= "?" LowercaseIdentifier !>> ":"

regex /* was "lexical" */ {
OptLabelColon
  ::= "?" LowercaseIdentifier ":"
}

regex /* was "lexical" */ {
InfixSymbol
  ::= InfixSymbol1
    | InfixSymbol2
    | InfixSymbol3
    | InfixSymbol4
    | InfixSymbol5
    | InfixSymbol6
    | InfixSymbol7
    | InfixSymbol8
}

regex /* was "token" */ {
InfixSymbol1
  ::= "lsl" | "lsr" | "asr"
    | [*][*] OperatorChar+
}

// InfixSymbol2 /* was "lexical" */
//   ::= "mod" | "land"| "lor" | "lxor"
//     | ([/ % *] OperatorChar*) !>> [! $ % & * + \- . / : < = > ? @ ^ | ~] \ "**"

// TODO InfixSymbol3 /* was "lexical" */
//   ::= ([+ \-] OperatorChar*) !>> [! $ % & * + \- . / : < = > ? @ ^ | ~] \ "->"

// TODO InfixSymbol4 /* was "lexical" */
//   ::= [@ ^] OperatorChar* !>> [! $ % & * + \- . / : < = > ? @ ^ | ~]

// TODO InfixSymbol5 /* was "lexical" */
//   ::= "!="
//     | ([= < > | & $] OperatorChar*) !>> [! $ % & * + \- . / : < = > ? @ ^ | ~] \ InfixSymbol5Exclude

regex /* was "token" */ {
InfixSymbol5Exclude
  ::= "|"
    | "||"
    | "&&"
    | "&"
    | "<-"
}

regex /* was "token" */ {
InfixSymbol6
  ::= "&"
    | "&&"
}

regex /* was "token" */ {
InfixSymbol7
  ::= "||"
    | "or"
}

regex /* was "token" */ {
InfixSymbol8
  ::= ":="
}

regex /* was "keywords" */ {
Keywords
  ::= "_"
    | "and"
    | "as"
    | "assert"
    | "asr"
    | "begin"
    | "class"
    | "constraint"
    | "do"
    | "done"
    | "downto"
    | "else"
    | "end"
    | "exception"
    | "external"
    | "false"
    | "for"
    | "fun"
    | "function"
    | "functor"
    | "if"
    | "in"
    | "include"
    | "inherit"
    | "initializer"
    | "land"
    | "lazy"
    | "let"
    | "lor"
    | "lsl"
    | "lsr"
    | "lxor"
    | "match"
    | "method"
    | "mod"
    | "module"
    | "mutable"
    | "new"
    | "object"
    | "of"
    | "open"
    | "or"
    | "private"
    | "rec"
    | "sig"
    | "struct"
    | "then"
    | "to"
    | "true"
    | "try"
    | "type"
    | "val"
    | "virtual"
    | "when"
    | "while"
    | "with"
}

// TODO Comment /* was "lexical" */
//   ::= "(*" ([^(*] | Comment | "*" !>> [)] | "(" !>> [*])* "*)"

// TODO: unicode literal \u0009-\u000D not working
regex /* was "token" */ {
Whitespace
  ::= [\ \t\n\r]+
}

// TODO: unicode literal \u0009-\u000D not working
@Layout /* was "layout" */
Layout
  ::= (Comment | Whitespace)* !>> [\ \t\n\r] !>> "(*"
